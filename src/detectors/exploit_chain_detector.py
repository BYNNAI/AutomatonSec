# BYNNÎ›I - AutomatonSec
# https://github.com/BYNNAI/AutomatonSec

import logging
from typing import Dict, List, Set, Tuple, Optional
from collections import defaultdict

logger = logging.getLogger(__name__)


class ExploitChainDetector:
    """
    Detects multi-step exploit chains and complex attack scenarios.
    Combines multiple vulnerability types into exploitable attack vectors.
    """
    
    def __init__(self):
        self.exploit_chains = []
        
    def detect(self, bytecode_analysis: Dict, cfg: Dict,
               taint_results: Dict, symbolic_results: Dict,
               fuzzing_results: Dict) -> List[Dict]:
        """
        Detect complex multi-step exploit chains.
        """
        logger.info("Detecting exploit chains")
        
        self.exploit_chains = []
        
        vulnerable_states = symbolic_results.get("vulnerable_states", [])
        taint_flows = taint_results.get("taint_flows", [])
        
        self._detect_reentrancy_flashloan_combo(vulnerable_states, taint_flows)
        
        self._detect_access_control_bypass_chain(cfg, taint_flows)
        
        self._detect_state_manipulation_chain(symbolic_results)
        
        self._rank_exploit_chains()
        
        logger.info(f"Found {len(self.exploit_chains)} exploit chains")
        return self.exploit_chains
    
    def _detect_reentrancy_flashloan_combo(self, vulnerable_states: List[Dict],
                                           taint_flows: List[Dict]):
        """
        Detect combination of reentrancy and flash loan vulnerabilities.
        """
        reentrancy_states = [
            s for s in vulnerable_states
            if s.get("vulnerability_type") == "POTENTIAL_REENTRANCY"
        ]
        
        critical_taints = [
            t for t in taint_flows
            if t.get("severity") == "CRITICAL"
        ]
        
        if reentrancy_states and critical_taints:
            self.exploit_chains.append({
                "type": "REENTRANCY_FLASHLOAN_EXPLOIT",
                "severity": "CRITICAL",
                "description": "Reentrancy vulnerability can be exploited with flash loan to amplify damage",
                "steps": [
                    "1. Obtain flash loan for large capital",
                    "2. Trigger reentrancy vulnerability",
                    "3. Recursively drain contract funds",
                    "4. Repay flash loan and keep profit"
                ],
                "reentrancy_count": len(reentrancy_states),
                "taint_flow_count": len(critical_taints),
                "confidence": 0.85,
                "profit_potential": "VERY_HIGH",
                "complexity": "MEDIUM"
            })
    
    def _detect_access_control_bypass_chain(self, cfg: Dict,
                                            taint_flows: List[Dict]):
        """
        Detect access control bypass through multiple steps.
        """
        uncontrolled_flows = [
            flow for flow in taint_flows
            if flow.get("sink_type") in ['DELEGATECALL', 'SELFDESTRUCT']
        ]
        
        if len(uncontrolled_flows) >= 2:
            self.exploit_chains.append({
                "type": "ACCESS_CONTROL_BYPASS_CHAIN",
                "severity": "CRITICAL",
                "description": "Multiple uncontrolled critical operations enable privilege escalation",
                "steps": [
                    "1. Exploit first taint flow to gain partial control",
                    "2. Use gained control to bypass access checks",
                    "3. Execute privileged operation (DELEGATECALL/SELFDESTRUCT)"
                ],
                "vulnerable_operations": len(uncontrolled_flows),
                "confidence": 0.75,
                "profit_potential": "HIGH",
                "complexity": "HIGH"
            })
    
    def _detect_state_manipulation_chain(self, symbolic_results: Dict):
        """
        Detect state manipulation exploit chains.
        """
        interesting_paths = symbolic_results.get("interesting_paths", [])
        
        complex_paths = [
            path for path in interesting_paths
            if len(path.get("constraints", [])) > 10
        ]
        
        for path in complex_paths[:5]:
            final_state = path.get("final_state", {})
            
            if (final_state.get("external_calls", 0) > 0 and
                final_state.get("storage_writes", 0) > 3):
                
                self.exploit_chains.append({
                    "type": "STATE_MANIPULATION_CHAIN",
                    "severity": "HIGH",
                    "description": "Complex execution path enables sophisticated state manipulation",
                    "path_id": path.get("path_id"),
                    "constraint_count": len(path.get("constraints", [])),
                    "storage_writes": final_state.get("storage_writes", 0),
                    "confidence": 0.65,
                    "profit_potential": "MEDIUM",
                    "complexity": "VERY_HIGH"
                })
    
    def _rank_exploit_chains(self):
        """
        Rank exploit chains by severity and exploitability.
        """
        severity_scores = {
            "CRITICAL": 100,
            "HIGH": 75,
            "MEDIUM": 50,
            "LOW": 25
        }
        
        profit_scores = {
            "VERY_HIGH": 50,
            "HIGH": 35,
            "MEDIUM": 20,
            "LOW": 10
        }
        
        for chain in self.exploit_chains:
            score = 0
            score += severity_scores.get(chain.get("severity", "LOW"), 0)
            score += profit_scores.get(chain.get("profit_potential", "LOW"), 0)
            score += chain.get("confidence", 0) * 50
            
            chain["exploit_score"] = score
        
        self.exploit_chains.sort(key=lambda x: x.get("exploit_score", 0), reverse=True)
